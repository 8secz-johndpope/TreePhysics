The biggest optimization for doing highly detailed trees is by analogy to tesselation;

Let each RigidBody have a set (16) of turtle instructions: 16 bytes
If we need any constants (step size, etc.), store 8 halfs => 32 bytes

For each updatCompositeBodies step (which is leaf to root order) replay the turtle commands (in reverse order in this step -- is that possible?) accumulating the force, torque, etc.

Calculate the joint angles immediately -- there's no avoiding this, unfortunately.

===

let captureManager = MTLCaptureManager.shared()

guard captureManager.supportsDestination(.gpuTraceDocument) else
{
print("Capture to a GPU tracefile is not supported")
return
}

let captureDescriptor = MTLCaptureDescriptor()
captureDescriptor.captureObject = self.device
captureDescriptor.destination = .gpuTraceDocument
captureDescriptor.outputURL = self.traceURL

==

// Create myCaptureScope outside of your rendering loop.
myCaptureScope?.begin()
let commandBuffer = commandQueue.makeCommandBuffer()!
// Do Metal work
commandBuffer.commit()
myCaptureScope?.end()


====

enum kind_en { knothing, kint, kfloat, kstring };
struct value_st {
enum kind_en kind;
union {
int n;     // when kint
float f;   // when kfloat
char* s;   // when kstring
};
};

===

                let torqueFictitious_jointSpace_ii = -inertiaTensor_jointSpace * (parentAngularAcceleration_jointSpace + parentAngularVelocity_jointSpace.crossMatrix * childAngularVelocity_jointSpace)
